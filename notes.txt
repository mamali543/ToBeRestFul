                        Developing a quality API
    In this project you will learn how to use Spring mechanisms to develop REST applications

Preamble:
    Levels of compliance of an application’s API to the REST architecture as per Richardson
    model (each subsequent level is based on the previous one):
    - Level 0. HTTP is used as a transport protocol. A single URI is used for all
    interactions. All required information is passed in plain XML text.
    - Level 1. The API uses a "resource" concept. Each resource is a separate business
    object. Each resource has its own URI. All interactions are described by a single HTTP verb.
    - Level 2. All interactions are described by an extended set of HTTP verbs: GET
    (getting an entity), POST (adding a new entity), PUT (updating an existing entity), and
    DELETE. Hence, a CRUD is defined for each resource.
    - Level 3. The API is based on Hypermedia format.



                          /*---------------------------------- Spring Component Scanning ----------------------------------*/

Spring does indeed have a component scanning mechanism that scans your application's classes and automatically registers beans in the Spring container. This is a key feature of Spring's Inversion of Control (IoC) container.
Let me elaborate on this:

Component Scanning:
Spring's component scanning is a feature that automatically detects and registers Spring beans without requiring explicit bean declarations in XML or Java configuration.

openssl rand -hex 32

                          /*---------------------------------- Spring Security ----------------------------------*/

1. URL-based security in SecurityConfig
2. Method-level security with @PreAuthorize annotations
The combination of both provides robust security, allowing you to control
access to different parts of your application based on both the URL and the
user's role.

Session based authentication
JWT based authentication and role-based access control (RBAC). 

stateful : the request share the same session context
stateless : the request is independent of each other

JWT is stateless
Session is stateful

jwtService.extractUsername(jwt) knows to extract the login field because When generating the token, we set the subject of the JWT to userDetails.getUsername()

                          /*----------------------------------JDBC implementation vs Spring Data JPA ----------------------------------*/
JDBC Implementation
    1. Direct Database Interaction: JDBC (Java Database Connectivity) is indeed a low-level API that allows you to connect to a database and execute SQL queries directly. You have to manage the connection, execute queries, and handle results manually.
    2. Connection Pooling: Using a connection pool like HikariCP is a good practice to manage database connections efficiently. It helps in reusing connections rather than creating a new one for every request, which can be resource-intensive.
    3. Manual SQL Queries: You need to write raw SQL queries, which can lead to more boilerplate code and potential SQL injection vulnerabilities if not handled properly.
    4. Schema Definition: Creating a schema.sql file to define your tables and relationships is a common practice in JDBC, as you need to set up the database schema manually.
    5. Object Mapping: You have to manually map the result set to your Java objects, which can be tedious and error-prone.

Spring Data JPA
    1. Abstraction Layer: Spring Data JPA provides a higher-level abstraction over JDBC, allowing you to interact with the database using Java objects rather than raw SQL.
    2. Reduced Boilerplate Code: It significantly reduces the amount of boilerplate code you need to write. You can define repository interfaces, and Spring Data JPA will automatically implement them for you.
    3. ORM (Object-Relational Mapping): With JPA (Java Persistence API), you can use annotations to define how your Java objects map to database tables. This is done using an ORM framework like Hibernate, which handles the mapping and querying for you.
    Automatic Configuration: Spring Data JPA automatically configures the data source and manages the entity lifecycle, which simplifies the setup process.
    5. Query Methods: You can define query methods in your repository interfaces, and Spring Data JPA will generate the necessary SQL queries based on the method names, which is much easier than writing SQL manually.
Summary
    JDBC is more manual and requires more boilerplate code, while Spring Data JPA abstracts much of that complexity away, allowing for cleaner and more maintainable code.
    Spring Data JPA leverages annotations and reflection to simplify the mapping of Java objects to database tables, whereas JDBC requires explicit SQL and manual mapping.
    
*spring data jpa : simplifies data access layer implementation by reducing boilerplate code,
and it is a framework within the spring ecosystem dedicated to handle the communication between the objects model and the relational databases schema through object-relational-mapping
uses hibernate as its default jpa implementation

                                /******************************************************************** Prevent malicious attacks **********************************************************************\

1. HTTPS (Baseline Protection)
    How It Works:
        Ensure all requests use HTTPS, which encrypts the request body and headers and URL in transit.
Use HTTPS and consider 2FA for critical operations.
one-time-use, transaction-specific JWT

2. Sign the Initiate Request Payload
    How It Works:
    The client signs the request body ({"toWallet": "walletX", "amount": "y"}) using a secret key or a key derived from the session JWT, and includes the signature in a header (e.g., X-Request-Signature).

    Example:
    Request body: {"toWallet": "walletX", "amount": "y"}

    Signature: HMAC-SHA256(body, session-jwt-secret)

    Request:
    http

    POST /transfer/initiate
    Authorization: Bearer <session-jwt>
    X-Request-Signature: <signature>
    Content-Type: application/json
    {
    "toWallet": "walletX",
    "amount": "y"
    }

    The server:
    Recomputes the signature using the same secret key and the received body.

    Compares it to X-Request-Signature.

    Rejects the request if they don’t match.

3. Client-Side Confirmation Before Submission
    How It Works:
    After receiving the transaction-specific JWT from /transfer/initiate, the client displays a confirmation screen to the user (e.g., “Confirm transfer of y to walletX?”) before submitting the final /transfer request.

    The user must explicitly approve the details, which are pulled from the transaction JWT, not the original request.

    Why It Prevents Tampering:
    Even if the attacker changes toWallet=walletX to walletZ in the initial request, the client app will display walletZ in the confirmation (since it’s in the returned JWT). The user will notice the discrepancy and reject the transfer.



